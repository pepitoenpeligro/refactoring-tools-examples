id: append_logger_import_after_last_import_from
language: python
rule:
  all:
    - kind: import_from_statement
    - pattern: $I
    - inside: { kind: module }
    - not:
        precedes:
          any:
            - kind: import_statement
            - kind: import_from_statement
          stopBy: neighbor
    - not:
        follows:
          any:
            - kind: function_definition
            - kind: class_definition
            - kind: decorated_definition
            - kind: assignment
            - kind: if_statement
            - kind: try_statement
            - kind: for_statement
            - kind: while_statement
          stopBy: end
    - not:
        inside:
          kind: module
          has:
            pattern: from aws_lambda_powertools import Logger
            stopBy: end
fix: |
  $I
  from aws_lambda_powertools import Logger
  logger = Logger()
message: "Añade 'from aws_lambda_powertools import Logger' al final del bloque de imports."
# --- Notes ------------------------------------------------------------
# Matches the last `from ... import ...` in the initial import block and
# appends the Powertools import + `logger = Logger()`.
# We avoid duplicating the import with the final `not: inside ... has ...`.
# IMPORTANT: keep comments OUTSIDE the `fix: |` block, or they will be
# inserted into your Python file.
# ---------------------------------------------------------------------

---
id: replace_print_with_logger_info
language: python
rule:
  kind: call
  pattern: print($$$ARGS)
fix: logger.info($$$ARGS)
message: "Usa logger.info(...) en lugar de print(...)."
# --- Notes ------------------------------------------------------------
# Replaces any `print(...)` call with `logger.info(...)`, preserving args.
# If you want to skip keyword-arg prints (sep=, end=, etc.), add:
#   not:
#     has:
#       kind: keyword_argument
# ---------------------------------------------------------------------

---
id: lambda_handler_insert_event_log_after_docstring
language: python
rule:
  all:
    # Target: el propio docstring (expresión string) dentro del cuerpo
    - kind: expression_statement
    - pattern: $DOC
    - has: { kind: string }
    # Debe venir inmediatamente antes de otra sentencia (usamos follows en la siguiente regla,
    # pero aquí reescribimos el docstring para "añadir" la línea debajo)
    - inside:
        all:
          # Trabajamos dentro del bloque (cuerpo) de la función
          - kind: block
          # Ese bloque pertenece a un lambda_handler tipado (con o sin return)
          - inside:
              all:
                - kind: function_definition
                - any:
                    - pattern: |
                        def lambda_handler(event: $T1, context: $T2) -> $RET:
                            $$$BODY
                    - pattern: |
                        def lambda_handler(event: $T1, context: $T2):
                            $$$BODY
          # Evita añadir si ya hay un log/print del event como sentencia directa del bloque
          - not:
              has:
                any:
                  - pattern: logger.$METHOD(event, $$$REST)
                  - pattern: print(event, $$$REST)
fix: |
  $DOC
  logger.info('Event received:', extra=event)
message: "Inserta logger.info(event) tras el docstring en lambda_handler(event, context)."
